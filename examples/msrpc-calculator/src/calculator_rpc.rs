// Generated by midlc from examples/msrpc-calculator/calculator.idl
// DO NOT EDIT

#[allow(unused_imports)]
use bytes::{Buf, BufMut, Bytes, BytesMut};
#[allow(unused_imports)]
use midl_ndr::{NdrContext, NdrEncode, NdrDecode, Result as NdrResult};
pub const ICALCULATOR_UUID: &str = "12345678-1234-5678-1234-567812345678";
pub const ICALCULATOR_VERSION: (u16, u16) = (1u16, 0u16);
pub mod icalculator_opnum {
    pub const ADD: u16 = 0u16;
    pub const SUBTRACT: u16 = 1u16;
    pub const MULTIPLY: u16 = 2u16;
    pub const DIVIDE: u16 = 3u16;
}
/// Client trait for #trait_name interface
#[async_trait::async_trait]
pub trait ICalculator: Send + Sync {
    async fn Add(&self, a: i32, b: i32) -> dcerpc::Result<i32>;
    async fn Subtract(&self, a: i32, b: i32) -> dcerpc::Result<i32>;
    async fn Multiply(&self, a: i32, b: i32) -> dcerpc::Result<i32>;
    async fn Divide(
        &self,
        a: i32,
        b: i32,
        remainder: &mut midl_ndr::UniquePtr<i32>,
    ) -> dcerpc::Result<i32>;
}
/// Client stub for #trait_name interface
pub struct ICalculatorClient {
    inner: dcerpc::DceRpcClient,
}
impl ICalculatorClient {
    /// Create a new client from an existing DceRpcClient
    pub fn new(client: dcerpc::DceRpcClient) -> Self {
        Self { inner: client }
    }
    /// Connect to a server and create a client
    pub async fn connect(addr: std::net::SocketAddr) -> dcerpc::Result<Self> {
        let interface = dcerpc::SyntaxId::new(
            dcerpc::Uuid::parse(ICALCULATOR_UUID).unwrap(),
            ICALCULATOR_VERSION.0,
            ICALCULATOR_VERSION.1,
        );
        let client = dcerpc::DceRpcClient::connect(addr, interface).await?;
        Ok(Self::new(client))
    }
    /// Get a reference to the underlying client
    pub fn inner(&self) -> &dcerpc::DceRpcClient {
        &self.inner
    }
    /// Call #method_name operation
    pub async fn add(&self, a: i32, b: i32) -> dcerpc::Result<i32> {
        let mut buf = BytesMut::new();
        let ctx = NdrContext::default();
        let mut position: usize = 0;
        a.ndr_encode(&mut buf, &ctx, &mut position)?;
        b.ndr_encode(&mut buf, &ctx, &mut position)?;
        let stub_data = buf.freeze();
        let response = self.inner.call(icalculator_opnum::ADD, stub_data).await?;
        let ctx = NdrContext::default();
        let mut cursor = response.as_ref();
        let mut position: usize = 0;
        let _return_value = <i32 as NdrDecode>::ndr_decode(
            &mut cursor,
            &ctx,
            &mut position,
        )?;
        Ok(_return_value)
    }
    /// Call #method_name operation
    pub async fn subtract(&self, a: i32, b: i32) -> dcerpc::Result<i32> {
        let mut buf = BytesMut::new();
        let ctx = NdrContext::default();
        let mut position: usize = 0;
        a.ndr_encode(&mut buf, &ctx, &mut position)?;
        b.ndr_encode(&mut buf, &ctx, &mut position)?;
        let stub_data = buf.freeze();
        let response = self.inner.call(icalculator_opnum::SUBTRACT, stub_data).await?;
        let ctx = NdrContext::default();
        let mut cursor = response.as_ref();
        let mut position: usize = 0;
        let _return_value = <i32 as NdrDecode>::ndr_decode(
            &mut cursor,
            &ctx,
            &mut position,
        )?;
        Ok(_return_value)
    }
    /// Call #method_name operation
    pub async fn multiply(&self, a: i32, b: i32) -> dcerpc::Result<i32> {
        let mut buf = BytesMut::new();
        let ctx = NdrContext::default();
        let mut position: usize = 0;
        a.ndr_encode(&mut buf, &ctx, &mut position)?;
        b.ndr_encode(&mut buf, &ctx, &mut position)?;
        let stub_data = buf.freeze();
        let response = self.inner.call(icalculator_opnum::MULTIPLY, stub_data).await?;
        let ctx = NdrContext::default();
        let mut cursor = response.as_ref();
        let mut position: usize = 0;
        let _return_value = <i32 as NdrDecode>::ndr_decode(
            &mut cursor,
            &ctx,
            &mut position,
        )?;
        Ok(_return_value)
    }
    /// Call #method_name operation
    pub async fn divide(
        &self,
        a: i32,
        b: i32,
    ) -> dcerpc::Result<(i32, midl_ndr::UniquePtr<i32>)> {
        let mut buf = BytesMut::new();
        let ctx = NdrContext::default();
        let mut position: usize = 0;
        a.ndr_encode(&mut buf, &ctx, &mut position)?;
        b.ndr_encode(&mut buf, &ctx, &mut position)?;
        let stub_data = buf.freeze();
        let response = self.inner.call(icalculator_opnum::DIVIDE, stub_data).await?;
        let ctx = NdrContext::default();
        let mut cursor = response.as_ref();
        let mut position: usize = 0;
        let remainder = <midl_ndr::UniquePtr<
            i32,
        > as NdrDecode>::ndr_decode(&mut cursor, &ctx, &mut position)?;
        let _return_value = <i32 as NdrDecode>::ndr_decode(
            &mut cursor,
            &ctx,
            &mut position,
        )?;
        Ok((_return_value, remainder))
    }
}
/// Server trait for implementing the interface
#[async_trait::async_trait]
pub trait ICalculatorServer: Send + Sync + 'static {
    async fn add(&self, a: i32, b: i32) -> dcerpc::Result<i32>;
    async fn subtract(&self, a: i32, b: i32) -> dcerpc::Result<i32>;
    async fn multiply(&self, a: i32, b: i32) -> dcerpc::Result<i32>;
    async fn divide(
        &self,
        a: i32,
        b: i32,
    ) -> dcerpc::Result<(i32, midl_ndr::UniquePtr<i32>)>;
}
/// Create a DCE RPC interface from an implementation
pub fn create_i_calculator_interface<T: ICalculatorServer>(
    impl_: std::sync::Arc<T>,
) -> dcerpc::Interface {
    async fn handle_add<T: ICalculatorServer>(
        impl_: std::sync::Arc<T>,
        stub_data: Bytes,
    ) -> dcerpc::Result<Bytes> {
        let ctx = NdrContext::default();
        let mut cursor = stub_data.as_ref();
        let mut position: usize = 0;
        let a = <i32 as NdrDecode>::ndr_decode(&mut cursor, &ctx, &mut position)?;
        let b = <i32 as NdrDecode>::ndr_decode(&mut cursor, &ctx, &mut position)?;
        let result = impl_.add(a, b).await?;
        let mut buf = BytesMut::new();
        let ctx = NdrContext::default();
        let mut position: usize = 0;
        result.ndr_encode(&mut buf, &ctx, &mut position)?;
        Ok(buf.freeze())
    }
    async fn handle_subtract<T: ICalculatorServer>(
        impl_: std::sync::Arc<T>,
        stub_data: Bytes,
    ) -> dcerpc::Result<Bytes> {
        let ctx = NdrContext::default();
        let mut cursor = stub_data.as_ref();
        let mut position: usize = 0;
        let a = <i32 as NdrDecode>::ndr_decode(&mut cursor, &ctx, &mut position)?;
        let b = <i32 as NdrDecode>::ndr_decode(&mut cursor, &ctx, &mut position)?;
        let result = impl_.subtract(a, b).await?;
        let mut buf = BytesMut::new();
        let ctx = NdrContext::default();
        let mut position: usize = 0;
        result.ndr_encode(&mut buf, &ctx, &mut position)?;
        Ok(buf.freeze())
    }
    async fn handle_multiply<T: ICalculatorServer>(
        impl_: std::sync::Arc<T>,
        stub_data: Bytes,
    ) -> dcerpc::Result<Bytes> {
        let ctx = NdrContext::default();
        let mut cursor = stub_data.as_ref();
        let mut position: usize = 0;
        let a = <i32 as NdrDecode>::ndr_decode(&mut cursor, &ctx, &mut position)?;
        let b = <i32 as NdrDecode>::ndr_decode(&mut cursor, &ctx, &mut position)?;
        let result = impl_.multiply(a, b).await?;
        let mut buf = BytesMut::new();
        let ctx = NdrContext::default();
        let mut position: usize = 0;
        result.ndr_encode(&mut buf, &ctx, &mut position)?;
        Ok(buf.freeze())
    }
    async fn handle_divide<T: ICalculatorServer>(
        impl_: std::sync::Arc<T>,
        stub_data: Bytes,
    ) -> dcerpc::Result<Bytes> {
        let ctx = NdrContext::default();
        let mut cursor = stub_data.as_ref();
        let mut position: usize = 0;
        let a = <i32 as NdrDecode>::ndr_decode(&mut cursor, &ctx, &mut position)?;
        let b = <i32 as NdrDecode>::ndr_decode(&mut cursor, &ctx, &mut position)?;
        let result = impl_.divide(a, b).await?;
        let mut buf = BytesMut::new();
        let ctx = NdrContext::default();
        let mut position: usize = 0;
        result.1.ndr_encode(&mut buf, &ctx, &mut position)?;
        result.0.ndr_encode(&mut buf, &ctx, &mut position)?;
        Ok(buf.freeze())
    }
    dcerpc::InterfaceBuilder::new(
            ICALCULATOR_UUID,
            ICALCULATOR_VERSION.0,
            ICALCULATOR_VERSION.1,
        )
        .unwrap()
        .operation(
            0u16,
            {
                let impl_clone = impl_.clone();
                move |stub_data| {
                    let impl_ = impl_clone.clone();
                    Box::pin(handle_add(impl_, stub_data))
                }
            },
        )
        .operation(
            1u16,
            {
                let impl_clone = impl_.clone();
                move |stub_data| {
                    let impl_ = impl_clone.clone();
                    Box::pin(handle_subtract(impl_, stub_data))
                }
            },
        )
        .operation(
            2u16,
            {
                let impl_clone = impl_.clone();
                move |stub_data| {
                    let impl_ = impl_clone.clone();
                    Box::pin(handle_multiply(impl_, stub_data))
                }
            },
        )
        .operation(
            3u16,
            {
                let impl_clone = impl_.clone();
                move |stub_data| {
                    let impl_ = impl_clone.clone();
                    Box::pin(handle_divide(impl_, stub_data))
                }
            },
        )
        .build()
}
