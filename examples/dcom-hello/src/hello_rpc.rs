// Generated by midlc from examples/dcom-hello/hello.idl
// DO NOT EDIT

#[allow(unused_imports)]
use bytes::{Buf, BufMut, Bytes, BytesMut};
#[allow(unused_imports)]
use midl_ndr::{NdrContext, NdrEncode, NdrDecode, Result as NdrResult};
pub const IHELLO_UUID: &str = "87654321-4321-8765-4321-876543218765";
pub const IHELLO_VERSION: (u16, u16) = (0u16, 0u16);
pub mod ihello_opnum {
    pub const SAYHELLO: u16 = 0u16;
    pub const ECHO: u16 = 1u16;
}
/// Client trait for #trait_name interface
#[async_trait::async_trait]
pub trait IHello: Send + Sync {
    async fn SayHello(
        &self,
        name: midl_ndr::NdrString,
        greeting: &mut midl_ndr::NdrString,
    ) -> dcerpc::Result<i32>;
    async fn Echo(
        &self,
        message: midl_ndr::NdrString,
        response: &mut midl_ndr::NdrString,
    ) -> dcerpc::Result<i32>;
}
/// Client stub for #trait_name interface
pub struct IHelloClient {
    inner: dcerpc::DceRpcClient,
}
impl IHelloClient {
    /// Create a new client from an existing DceRpcClient
    pub fn new(client: dcerpc::DceRpcClient) -> Self {
        Self { inner: client }
    }
    /// Connect to a server and create a client
    pub async fn connect(addr: std::net::SocketAddr) -> dcerpc::Result<Self> {
        let interface = dcerpc::SyntaxId::new(
            dcerpc::Uuid::parse(IHELLO_UUID).unwrap(),
            IHELLO_VERSION.0,
            IHELLO_VERSION.1,
        );
        let client = dcerpc::DceRpcClient::connect(addr, interface).await?;
        Ok(Self::new(client))
    }
    /// Get a reference to the underlying client
    pub fn inner(&self) -> &dcerpc::DceRpcClient {
        &self.inner
    }
    /// Call #method_name operation
    pub async fn say_hello(
        &self,
        name: midl_ndr::NdrString,
    ) -> dcerpc::Result<(i32, midl_ndr::NdrString)> {
        let mut buf = BytesMut::new();
        let ctx = NdrContext::default();
        let mut position: usize = 0;
        name.ndr_encode(&mut buf, &ctx, &mut position)?;
        let stub_data = buf.freeze();
        let response = self.inner.call(ihello_opnum::SAYHELLO, stub_data).await?;
        let ctx = NdrContext::default();
        let mut cursor = response.as_ref();
        let mut position: usize = 0;
        let greeting = <midl_ndr::NdrString as NdrDecode>::ndr_decode(
            &mut cursor,
            &ctx,
            &mut position,
        )?;
        let _return_value = <i32 as NdrDecode>::ndr_decode(
            &mut cursor,
            &ctx,
            &mut position,
        )?;
        Ok((_return_value, greeting))
    }
    /// Call #method_name operation
    pub async fn echo(
        &self,
        message: midl_ndr::NdrString,
    ) -> dcerpc::Result<(i32, midl_ndr::NdrString)> {
        let mut buf = BytesMut::new();
        let ctx = NdrContext::default();
        let mut position: usize = 0;
        message.ndr_encode(&mut buf, &ctx, &mut position)?;
        let stub_data = buf.freeze();
        let response = self.inner.call(ihello_opnum::ECHO, stub_data).await?;
        let ctx = NdrContext::default();
        let mut cursor = response.as_ref();
        let mut position: usize = 0;
        let response = <midl_ndr::NdrString as NdrDecode>::ndr_decode(
            &mut cursor,
            &ctx,
            &mut position,
        )?;
        let _return_value = <i32 as NdrDecode>::ndr_decode(
            &mut cursor,
            &ctx,
            &mut position,
        )?;
        Ok((_return_value, response))
    }
}
/// Server trait for implementing the interface
#[async_trait::async_trait]
pub trait IHelloServer: Send + Sync + 'static {
    async fn say_hello(
        &self,
        name: midl_ndr::NdrString,
    ) -> dcerpc::Result<(i32, midl_ndr::NdrString)>;
    async fn echo(
        &self,
        message: midl_ndr::NdrString,
    ) -> dcerpc::Result<(i32, midl_ndr::NdrString)>;
}
/// Create a DCE RPC interface from an implementation
pub fn create_i_hello_interface<T: IHelloServer>(
    impl_: std::sync::Arc<T>,
) -> dcerpc::Interface {
    async fn handle_say_hello<T: IHelloServer>(
        impl_: std::sync::Arc<T>,
        stub_data: Bytes,
    ) -> dcerpc::Result<Bytes> {
        let ctx = NdrContext::default();
        let mut cursor = stub_data.as_ref();
        let mut position: usize = 0;
        let name = <midl_ndr::NdrString as NdrDecode>::ndr_decode(
            &mut cursor,
            &ctx,
            &mut position,
        )?;
        let result = impl_.say_hello(name).await?;
        let mut buf = BytesMut::new();
        let ctx = NdrContext::default();
        let mut position: usize = 0;
        result.1.ndr_encode(&mut buf, &ctx, &mut position)?;
        result.0.ndr_encode(&mut buf, &ctx, &mut position)?;
        Ok(buf.freeze())
    }
    async fn handle_echo<T: IHelloServer>(
        impl_: std::sync::Arc<T>,
        stub_data: Bytes,
    ) -> dcerpc::Result<Bytes> {
        let ctx = NdrContext::default();
        let mut cursor = stub_data.as_ref();
        let mut position: usize = 0;
        let message = <midl_ndr::NdrString as NdrDecode>::ndr_decode(
            &mut cursor,
            &ctx,
            &mut position,
        )?;
        let result = impl_.echo(message).await?;
        let mut buf = BytesMut::new();
        let ctx = NdrContext::default();
        let mut position: usize = 0;
        result.1.ndr_encode(&mut buf, &ctx, &mut position)?;
        result.0.ndr_encode(&mut buf, &ctx, &mut position)?;
        Ok(buf.freeze())
    }
    dcerpc::InterfaceBuilder::new(IHELLO_UUID, IHELLO_VERSION.0, IHELLO_VERSION.1)
        .unwrap()
        .operation(
            0u16,
            {
                let impl_clone = impl_.clone();
                move |stub_data| {
                    let impl_ = impl_clone.clone();
                    Box::pin(handle_say_hello(impl_, stub_data))
                }
            },
        )
        .operation(
            1u16,
            {
                let impl_clone = impl_.clone();
                move |stub_data| {
                    let impl_ = impl_clone.clone();
                    Box::pin(handle_echo(impl_, stub_data))
                }
            },
        )
        .build()
}
