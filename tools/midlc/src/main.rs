//! MIDL Compiler CLI
//!
//! Compiles MIDL IDL files to Rust source code with NDR encoding/decoding.
//!
//! # Usage
//!
//! ```bash
//! midlc input.idl -o output.rs
//! midlc input.idl --client-only -o client.rs
//! midlc input.idl --server-only -o server.rs
//! midlc input.idl --check  # Syntax check only
//! ```

use clap::{Parser, ValueEnum};
use midl::{compile, parse, CompileOptions};
use std::fs;
use std::path::PathBuf;
use std::process;

/// MIDL Compiler - Compile IDL files to Rust code
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Input IDL file
    #[arg(required = true)]
    input: PathBuf,

    /// Output Rust file (defaults to stdout)
    #[arg(short, long)]
    output: Option<PathBuf>,

    /// Generation mode
    #[arg(short, long, value_enum, default_value = "all")]
    mode: GenerateMode,

    /// Syntax check only (no code generation)
    #[arg(long)]
    check: bool,

    /// Show parsed AST (for debugging)
    #[arg(long)]
    show_ast: bool,

    /// Module name for generated code
    #[arg(long)]
    module: Option<String>,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, ValueEnum)]
enum GenerateMode {
    /// Generate client and server stubs
    All,
    /// Generate client stubs only
    Client,
    /// Generate server stubs only
    Server,
    /// Generate type definitions only
    Types,
}

fn main() {
    let args = Args::parse();

    // Read input file
    let input = match fs::read_to_string(&args.input) {
        Ok(content) => content,
        Err(e) => {
            eprintln!("Error reading {}: {}", args.input.display(), e);
            process::exit(1);
        }
    };

    // Parse the IDL
    let file = match parse(&input) {
        Ok(file) => file,
        Err(e) => {
            eprintln!("Parse error in {}: {}", args.input.display(), e);
            process::exit(1);
        }
    };

    // Show AST if requested
    if args.show_ast {
        println!("// AST for {}", args.input.display());
        println!("{:#?}", file);
        println!();
    }

    // If just checking syntax, we're done
    if args.check {
        println!("Syntax OK: {}", args.input.display());
        return;
    }

    // Set up compile options based on mode
    let options = match args.mode {
        GenerateMode::All => CompileOptions::all(),
        GenerateMode::Client => CompileOptions::client_only(),
        GenerateMode::Server => CompileOptions::server_only(),
        GenerateMode::Types => CompileOptions {
            generate_client: false,
            generate_server: false,
            generate_types: true,
            module_name: None,
        },
    };

    let options = if let Some(ref module) = args.module {
        options.with_module_name(module)
    } else {
        options
    };

    // Compile
    let result = match compile(&input, &options) {
        Ok(result) => result,
        Err(e) => {
            eprintln!("Compilation error: {}", e);
            process::exit(1);
        }
    };

    // Generate header comment
    let header = format!(
        "// Generated by midlc from {}\n// DO NOT EDIT\n\n",
        args.input.display()
    );

    let output_code = format!("{}{}", header, result.rust_code);

    // Write output
    match args.output {
        Some(path) => {
            if let Err(e) = fs::write(&path, &output_code) {
                eprintln!("Error writing {}: {}", path.display(), e);
                process::exit(1);
            }
            println!("Generated {} ({} interfaces, {} types)",
                path.display(),
                result.interfaces.len(),
                result.types.len()
            );
        }
        None => {
            print!("{}", output_code);
        }
    }
}
